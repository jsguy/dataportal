<html>
<head>
	<title></title>
	<script type="text/javascript" src="js/jsondiffpatch.js"></script>
	<script type="text/javascript" src="js/sockjs-1.0.3.js"></script>
	<script type="text/javascript" src="js/jquery-1.11.3.js"></script>
	<script type="text/javascript" src="js/hash.js"></script>
	<script type="text/javascript" src="js/knockout-3.3.0.js"></script>
</head>
<body>

<script>

//    DOS: De-coupled Object Subscribable (pub/sub, with value check, to break infinite loops), 
//  see future article on jsguy.com!
//  This allows de-coupled updating of elements and models in a widget, similar to KO, AngularJS, etc...
//	Differences: 
//
//	1. We don't dictate the use of templates, or how things are rendered, you can use any templaing system you like
//	2. We encourage progressive enhancement and unobtrusiveness instead of a mix of templates and obtrusiveness
//
var DOS = function (value) {
	var self = function(val){
			if(typeof val !== "undefined") {
				return self.set(val);
			}
			return self.get();

		},
		subs = [],
		value = value,
		prevValue,
		//	Send notifications to subscribers
		notify = function (value) {
			var i;
			for (i = 0; i < subs.length; i += 1) {
				subs[i].func.apply(subs[i].context, [value]);
			}
		};

	//  Set a value - trigger notifications
	//  Will only trigger when the value has actually changed - this prevents infinite loops
	self.set = function (val) {
		value = val;
		if (prevValue !== value) {
			prevValue = value;
			notify(value);
		}
	};

	self.trigger = function (val) {
		notify((val !== undefined) ? val : value);
	};

	self.get = function () {
		return value;
	};

	self.subscribe = function (func, context) {
		subs.push({ func: func, context: context || self });
	};

	//	
	return self;
	// function(val){
	// 	if(typeof val !== "undefined") {
	// 		return self.set(val);
	// 	}
	// 	return self.get();
	// }
};

//	Create a new subscribable object
var dos = function(value) {
	return new DOS(value);
};


var obj = new DOS({hello: "world"});

obj.subscribe(function(value){
	console.log('value', value);
});

//console.log(obj());

obj({gday: "universe"});

//console.log(obj());



</script>


<!--


<button id="subscribe">Subscribe to myObject</button>
<button id="publish">Publish changed data</button>


<script>
//	NOTE: We can only have 1 connection to sockjs
var sock = new SockJS('http://localhost:9999/dataPortal');

/*
sock.onopen = function() {



	myPortal = new DataPortal("myObject", myObject);
	//	Update myObject
	myObject.something = "a thing";
	//	Let the portal know
	myPortal.publish(myObject);



};
*/
// sock.onmessage = function(e){
// 	var message = JSON.parse(e.data);
// 	if(message.type == "data") {
// 		//testData = message.data;
// 		console.log("got data", message);
// 	} else if(message.type == "diff") {
// 		console.log("got diff", message);
// 		//	Conditionally patch the data
			
// 		if(hash(testData) !== message.hash) {
// 			console.log("patch diff", message.diff);
// 			jsondiffpatch.patch(testData, message.diff);
// 		} else {
// 			console.log("hash already matches, no patch");
// 		}
		
// 	}

// 	//	Update log with data
// 	//$('#log').val(JSON.stringify(testData));
// };
/*
sock.onclose = function() {
	console.log('close');
};
*/
</script>

<script>


/*
	We need a data portal factoy that knows when the socket is ready, and can call the 'ready' methods on each data portal.

*/
(function(win, sock){
	var portals = [],
		subscriptions = {},
		getSubscribedPortals = function(topic){
			return subscriptions[topic] || [];
		},
		isReady = false,
		//	ref: http://stackoverflow.com/a/2117523
		guid = function() {
			return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
				var r = Math.random()*16|0, v = c == 'x' ? r : (r&0x3|0x8);
				return v.toString(16);
			});
		};

	//	Name is optional - it must be specified if you want to share the object with other browsers, so they can subscribe to it.
	//	The name will be generated if not specified, and you can have reactive data that the server can modify, and you can get the changes automatically.
	var DataPortal = function(obj, name){

		name = name || guid();

		var self = this,
			objectValue = obj,
			originalObj = JSON.parse(JSON.stringify(obj)),
			readyFunctions = [],
			value = function(newObj){
				if(typeof newObj !== "undefined") {
					objectValue = newObj;
				}
				return objectValue;
			},
			publish = function(newObj){
				var delta = jsondiffpatch.diff(originalObj, newObj);
				//	Send it
				sock.send(JSON.stringify({
					type: "publish",
					topic: name,
					message: {
						diff: delta,
						hash: hash(newObj)
					}
				}));
			},
			//	Subscribe to messages
			//	TODO: cache the last message, so we can always 
			//	give new subscribers the JSON object.
			subscribe = function(topic){
				console.log("subscribe", topic);

				//	Do it locally
				subscriptions[topic] = subscriptions[topic] || [];
				subscriptions[topic].push(self);

				//	Send it
				sock.send(JSON.stringify({
					type: "subscribe",
					topic: topic
				}));
			},
			//	When the socket is ready
			ready = function(cb){
				if(isReady) {
					cb(self);
				} else {
					readyFunctions.push({cb: cb, self: self});
				}
			};

		//	Always publish when created
		//publish(obj);

		//	Allow pub/sub
		return {
			value: value,
			publish: publish,
			subscribe: subscribe,
			ready: ready,
			readyFunctions: readyFunctions
		};
	};

	//	Handle sock open
	sock.onopen = function() {
		console.log('sock open');
		isReady = true;

		//	Loop on portals and call each ready method
		for(var i = 0; i < portals.length; i += 1) {
			console.log('ready', portals[i]);
			for(var j = 0; j < portals[i].readyFunctions.length; j += 1){
				portals[i].readyFunctions[j].cb(portals[i].readyFunctions[j].self);
			}
		}
	};


	//	Handle messages
	//	Note: the server holds the subscriptions, so assume that we only get messages that we care about.
	sock.onmessage = function(e){
		var message = JSON.parse(e.data);
		if(message.type == "data") {
			console.log("got data", message);
			var subs = getSubscribedPortals(message.topic), i;
			console.log(message.topic, 'data subs', subs);
			//	Set the data
			for(i = 0; i < subs.length; i += 1) {
				subs[i].value(message.data);
			}
		} else if(message.type == "diff") {
			console.log("got diff", message);
			//	Conditionally patch the data
			/*	
			if(hash(testData) !== message.hash) {
				console.log("patch diff", message.diff);
				jsondiffpatch.patch(testData, message.diff);
			} else {
				console.log("hash already matches, no patch");
			}
			*/

			var subs = getSubscribedPortals(message.topic), i;
			console.log(message.topic, 'diff subs', subs);

			//	Set the data
			for(i = 0; i < subs.length; i += 1) {
				if(hash(subs[i].value()) !== message.hash) {
					console.log("patch diff", message.diff);
					jsondiffpatch.patch(testData, message.diff);
				} else {
					console.log("hash already matches, no patch");
				}
			}


		} else {
			console.log("unrecognised message", message);
		}

		//	Update log with data
		//$('#log').val(JSON.stringify(testData));
	};

	sock.onclose = function() {
		console.log('close');
	};

	win.DataPortalFactory = function(object, name){
		var myPortal = new DataPortal(object, name);
		portals.push(myPortal);
		return myPortal;
	};

}(window, sock));

</script>

<script>
var myObject = {
		thisis: "an object"
	},
	mp = DataPortalFactory(myObject, 'myObject');

mp.ready(function(portal){
	console.log('portal ready', portal);
	//	Subscribe to and update our object
	mp.subscribe("myObject");
	myObject.c = {f:"minor"};
	mp.publish(myObject);
});

</script>


<script>
/*
var myPortal,
	myObject = {
		thisis: "an object"
	};

$('#subscribe').click(function(){
	myPortal.subscribe("myObject");
});

$('#publish').click(function(){
	myObject.c = {f:"minor"};
	myPortal.publish(myObject);
});
*/
</script>

-->

</body>
</html>